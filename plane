
Сделано:
1. GetIndexPage
2. SignIn
3. SignUp
4. LogOut
5. GetMainMenu
6. GetAdminMenu
7. SecurityFilter
8. AddUserServlet
9. DeleteUserServlet
10. UpdateUserServlet


MySQL part:
0. Добавить в AddUser выбор роли
1. завязать через DAO AccountService
2. Сделать конфиг DB через XML
3. Все залогировать
4. Все протестировать
5. Сделать 2 версии: напрямую запросами через JDBC и посредством JPA

Заметки:
1. Каждый должен заниматься своим делом - проектировать и создавать базу должны одни, а написанием пользовательского
   софта должны заниматься другие, без прав на модификацию структуры базы. А по хорошему они не должны иметь даже доступа
   к таблицам, а лишь к хранимым процедурам (и функциям).
2. JPA шпаргалка https://habr.com/post/265061/
3. Для обработки ResultSet и проверки его, есть ли хоть одна строка, соответствующая запросу
    Если мы работает с только возвращенным ResultSet
    Как объясняется в документации, это возвращает false, если курсор не находится перед первой записью,
    или если нет строк в ResultSet.
    if (!resultSet.isBeforeFirst() ) {
        System.out.println("No data");
    }

    Или можно использовать
    if (!resultSet.next() ) {
        System.out.println("no data");
    } else {

        do {
         //statement(s)
        } while (resultSet.next());
    }

4. Тесты:
    юнит - модульное - методы и отдельные классы, без запуска приложения;
    компонентные - интеграционные - отдельные части системы, как совокупность классов выполняет свою функцию, частичный запуск, тестовая БД;
    системные - тестируют приложение целиком
    http://qala.io/blog/test-pyramid.html
5. Тесты БД сервиса:
    принято ли в коммерческих проектах делать юнит-тесты для DAO?
    Нет, не принято. Может и есть какие возможные случаи, но в общем это редкость.Ну и многие такие тесты все равно
    называют модульными. Да, это не совсем так, но это все равно самый низкий уровень тестов.

    Мокают сам DAO, никто в здравом уме не мокает Connection/DataSource и т.д.
    поскольку поддерживать такие тесты выходит слишком дорого - проще написать
    простенький интеграционный тест, который использует реальную базу данных.

    если ты все замокаешь, то тестировать останется нечего :) Тебе нужно использовать интеграцию Spring'a и JUnit,
    она позволяет инжектить бины прям в тесты. Так ты получишь ссылку на свою реализацию DAO.
    Можешь подсмотреть как это делается в JCommune.
    https://github.com/jtalks-org/jcommune/blob/4d11c237f11d0ca26e7e8b9e1183f28265360ac0/jcommune-model/src/test/java/org/jtalks/jcommune/model/dao/hibernate/UserHibernateDaoTest.java

    На основной базе данных не надо тестировать - может плохо закончиться. Создайте отдельный профиль для
    тестирования с настройками подключения к тестовой БД в конфигурации Spring.
    Это нормальная практика на крупных проектах тестировать через in-memory DB (базы данных в оперативной памяти)
    Или дефолтовая база данных H2. Дефолтовая, потому что она используется только на этапе разработки приложения,
    пока еще мы не определились с конкретной базой данных. Это делается для того, чтобы не приходилось настраивать
    полный энвайронмент для запуска приложения, который к тому же может поменяться.
6. Тестирование врапперов?
    Бесполезно!
7. Тестирование с dbUnit
    https://devcolibri.com/%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B1%D0%B4-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%88%D1%8C%D1%8E-dbunit/
8. Чтобы замокать void метод, нужно применить конструкцию:
    Mockito.doThrow(new Exception()).when(instance).methodName();
    на моем примере
    Mockito.doThrow(new DBException("addNewUser")).when(accountService).addNewUser(UNREGISTERED_LOGIN, UNREGISTERED_PASSWORD);
9. Список статус кодов HTTP при ошибке на сервере
    https://semantica.in/blog/chto-takoe-oshibka-servera.html
